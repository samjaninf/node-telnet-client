// Generated by CoffeeScript 1.7.1
(function() {
  var SUBNEG_BUFFER_SIZE, TELNET_COMMAND, TELNET_DATA, TELNET_DO, TELNET_DONT, TELNET_IAC, TELNET_OPTION, TELNET_SUBNEG, TELNET_SUBNEG_COMMAND, TELNET_SUB_BEGIN, TELNET_SUB_END, TELNET_WILL, TELNET_WONT, TelnetInput, Transform, util;

  SUBNEG_BUFFER_SIZE = 8192;

  TELNET_COMMAND = 'TELNET_COMMAND';

  TELNET_DATA = 'TELNET_DATA';

  TELNET_OPTION = 'TELNET_OPTION';

  TELNET_SUBNEG = 'TELNET_SUBNEG';

  TELNET_SUBNEG_COMMAND = 'TELNET_SUBNEG_COMMAND';

  TELNET_DO = 253;

  TELNET_DONT = 254;

  TELNET_IAC = 255;

  TELNET_SUB_BEGIN = 250;

  TELNET_SUB_END = 240;

  TELNET_WILL = 251;

  TELNET_WONT = 252;

  Transform = require('stream').Transform;

  util = require('util');

  TelnetInput = function(options) {
    if ((this instanceof TelnetInput) === false) {
      return new TelnetInput(options);
    }
    Transform.call(this, options);
    this.state = TELNET_DATA;
    this.subBuf = new Buffer(SUBNEG_BUFFER_SIZE);
    this._transform = function(chunk, encoding, done) {
      var i, _i, _ref;
      this.dataBuf = new Buffer(chunk.length);
      this.dataBufIndex = 0;
      for (i = _i = 0, _ref = chunk.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.handle(chunk[i]);
      }
      if (this.dataBufIndex > 0) {
        this.push(this.dataBuf.slice(0, this.dataBufIndex));
      }
      return done();
    };
    this.handle = function(chunkData) {
      switch (this.state) {
        case TELNET_DATA:
          switch (chunkData) {
            case TELNET_IAC:
              return this.state = TELNET_COMMAND;
            default:
              this.dataBuf[this.dataBufIndex] = chunkData;
              return this.dataBufIndex++;
          }
          break;
        case TELNET_COMMAND:
          switch (chunkData) {
            case TELNET_IAC:
              this.state = TELNET_DATA;
              this.dataBuf[this.dataBufIndex] = TELNET_IAC;
              return this.dataBufIndex++;
            case TELNET_DO:
            case TELNET_DONT:
            case TELNET_WILL:
            case TELNET_WONT:
            case TELNET_SUB_BEGIN:
              this.state = TELNET_OPTION;
              return this.command = chunkData;
            default:
              this.state = TELNET_DATA;
              return this.emit('command', chunkData);
          }
          break;
        case TELNET_OPTION:
          switch (this.command) {
            case TELNET_DO:
              this.state = TELNET_DATA;
              return this.emit('do', chunkData);
            case TELNET_DONT:
              this.state = TELNET_DATA;
              return this.emit('dont', chunkData);
            case TELNET_WILL:
              this.state = TELNET_DATA;
              return this.emit('will', chunkData);
            case TELNET_WONT:
              this.state = TELNET_DATA;
              return this.emit('wont', chunkData);
            case TELNET_SUB_BEGIN:
              this.state = TELNET_SUBNEG;
              this.option = chunkData;
              return this.subBufIndex = 0;
          }
          break;
        case TELNET_SUBNEG:
          switch (chunkData) {
            case TELNET_IAC:
              return this.state = TELNET_SUBNEG_COMMAND;
            default:
              this.subBuf[this.subBufIndex] = chunkData;
              return this.subBufIndex++;
          }
          break;
        case TELNET_SUBNEG_COMMAND:
          switch (chunkData) {
            case TELNET_IAC:
              this.state = TELNET_SUBNEG;
              this.subBuf[this.subBufIndex] = TELNET_IAC;
              return this.subBufIndex++;
            case TELNET_SUB_END:
              this.state = TELNET_DATA;
              return this.emit('sub', this.option, this.subBuf.slice(0, this.subBufIndex));
            default:
              return this.state = TELNET_SUBNEG;
          }
      }
    };
    return this;
  };

  util.inherits(TelnetInput, Transform);

  exports.TelnetInput = TelnetInput;

}).call(this);
